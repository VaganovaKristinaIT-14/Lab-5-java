# Лабораторная работа №5

## Задание 1.1

**Текст задания**  
В класс Дробь, добавить интерфейс на два метода: получение вещественного значения, установка числителя и установка знаменателя. Сгенерировать такую версию дроби, которая будет кэшировать вычисление вещественного значения. Если раннее в вашем варианте не было Дроби, то создайте сущность Дробь со следующими особенностями: Имеет числитель: целое число. Имеет знаменатель: целое число. Дробь может быть создана с указанием числителя и знаменателя. Может вернуть строковое представление вида "числитель/знаменатель". Необходимо корректно обрабатывать отрицательные значения. Учтите, что знаменатель не может быть отрицательным. Переопределите метод сравнения объектов по состоянию таким образом, чтобы две дроби считались одинаковыми тогда, когда у них одинаковые значения числителя и знаменателя.

**Описание**  
Класс Fraction реализует интерфейс FractionInterface. Поля класса: numerator (числитель, целое число), denominator (знаменатель, целое число), cachedValue (кэшированное вещественное значение). Конструктор принимает числитель и знаменатель, вызывает метод setValues для установки значений и нормализации знака. Метод normalizeSign обеспечивает неотрицательность знаменателя. Метод getDecimalValue возвращает вещественное значение дроби, используя кэширование: если значение уже вычислено, оно возвращается из кэша, иначе вычисляется и сохраняется. Метод setValues выполняет установку новых значений числителя и знаменателя. Сначала выполняется проверка знаменателя на ноль с выбросом исключения. Затем значения числителя и знаменателя проверяются на допустимый диапазон. После установки новых значений вызывается метод normalizeSign для корректировки знаков, чтобы знаменатель всегда был положительным. В завершении метода сбрасывается кэшированное вещественное значение в null, чтобы при следующем запросе оно было пересчитано с новыми параметрами. Метод toString возвращает строковое представление дроби. Метод equals переопределен для сравнения дробей по числителю и знаменателю.

**Тестирование**  
<img width="501" height="484" alt="image" src="https://github.com/user-attachments/assets/83d515bc-e4b2-45f3-bea3-c5fa429733d7" />


---

## Задание 2.1

**Текст задания**  
Количество мяуканий. Необходимо воспользоваться классом Кот и методом принимающим всех мяукающих из задачи 2.5.4. Необходимо таким образом передать кота в указанный метод, что бы после окончания его работы узнать сколько раз мяукал кот за время его работы. Перед вызовом метода создаем кота, отправляем ссылку на кота в метод, после окончания его работы выводим количество мяуканий на экран. Кота изменять нельзя.

**Описание**  
Интерфейс Meowable определяет метод meow. Класс Cat реализует интерфейс Meowable. Поля класса: name (имя кота, строка). Конструктор принимает имя. Метод meow выводит в консоль сообщение вида "Имя: мяу!". Метод toString возвращает строку "Кот: Имя". Класс CountingCat реализует интерфейс Meowable и используется для подсчета мяуканий. Поля: realCat (объект Cat), meowCount (счетчик мяуканий). Конструктор принимает объект Cat. Метод meow вызывает meow у realCat и увеличивает счетчик. Метод getMeowCount возвращает значение счетчика. Класс Sound содержит статический метод meowsCare, который принимает объект Meowable и вызывает его метод meow случайное количество раз (от 1 до 10). Для подсчета мяуканий объект Cat оборачивается в CountingCat, который передается в meowsCare. После выполнения выводится количество мяуканий.

**Тестирование**  
<img width="377" height="439" alt="image" src="https://github.com/user-attachments/assets/1ba1ace4-78d2-48a2-8d42-f53db1c7d34c" />



---

## Задание 3.6

**Текст задания**  
Составить программу, которая в списке L из каждой группы подряд идущих одинаковых элементов оставляет только один.

**Описание**  
Класс ListUtils содержит статический универсальный метод removeDuplicates. Метод принимает список элементов любого типа. Используется итератор для прохода по списку. В переменной previous хранится предыдущий элемент. На каждой итерации сравнивается текущий элемент с предыдущим. Если они равны, текущий элемент удаляется из списка с помощью итератора. Таким образом, в каждой группе подряд идущих одинаковых элементов остается только первый элемент. Метод обрабатывает списки любого типа, поддерживающего сравнение через equals.

**Тестирование**  
<img width="628" height="230" alt="image" src="https://github.com/user-attachments/assets/1837df14-0253-4ff4-b387-644bf682f3b2" />



---

## Задание 4.5

**Текст задания**  
В молочных магазинах города X продается сметана с жирностью 15, 20 и 25 процентов. В городе X был проведен мониторинг цен на сметану. Напишите эффективную по времени работы и по используемой памяти программу, которая будет определять для каждого вида сметаны, сколько магазинов продают ее дешевле всего. На вход программе сначала подается число магазинов N. В каждой из следующих N строк находится информация в следующем формате: <Фирма><Улица><Жирность><Цена> где <Фирма> -- строка, состоящая не более, чем из 20 символов без пробелов, <Улица> -- строка, состоящая не более, чем из 20 символов без пробелов, <Жирность> -- одно из чисел -- 15, 20 или 25, <Цена> -- целое число в диапазоне от 2000 до 5000, обозначающее стоимость одного литра сметаны в копейках. <Фирма> и <Улица>,<Улица> и <Жирность>, а также <Жирность> и <Цена> разделены ровно одним пробелом. Пример входной строки: Перекресток Короленко 25 120 Программа должна выводить через пробел 3 числа -- количество магазинов, продающих дешевле всего сметану с жирностью 15, 20 и 25 процентов. Если какой-то вид сметаны нигде не продавался, то следует вывести 0. Пример выходных данных: 12 10 0

**Описание**  
Класс SourCreamAnalyzer содержит методы для анализа данных о магазинах. Метод readDataFromFile читает все строки из файла. Метод analyzeStores принимает List<String> с данными магазинов и возвращает массив int[] из трех элементов. В методе инициализируются переменные int для хранения минимальных цен по каждой жирности. Используется Map<Integer, Integer> для хранения счетчиков магазинов с минимальными ценами. Для каждой строки данных извлекаются жирность и цена. Для каждой жирности обновляется минимальная цена и счетчик магазинов. Если цена текущего магазина меньше текущей минимальной, минимальная цена обновляется, а счетчик сбрасывается до 1. Если цена равна минимальной, счетчик увеличивается. После обработки всех данных возвращается массив из трех чисел: количества магазинов с минимальной ценой для каждой жирности. Метод isValidStoreData проверяет корректность строки данных: длина полей, допустимые значения жирности и цены.

**Тестирование**  
<img width="471" height="513" alt="image" src="https://github.com/user-attachments/assets/d80e913d-96f0-4a1f-be65-6d8d37dd3e3c" />


---

## Задание 5.9

**Текст задания**  
Файл содержит текст на русском языке. Какие цифры встречаются в тексте?

**Описание**  
Класс TextDigitAnalyzer содержит методы для работы с текстом. Метод readFullText читает весь текст из файла и возвращает его в виде строки. Метод findDigitsInText анализирует текст из файла и возвращает множество цифр, встречающихся в тексте. Используется BufferedReader для построчного чтения файла. Для каждого символа в строке проверяется, является ли он цифрой (с помощью Character.isDigit). Найденные цифры добавляются в LinkedHashSet, который автоматически устраняет дубликаты и сохраняет порядок добавления. Результатом является множество уникальных цифр, присутствующих в тексте.

**Тестирование**  
<img width="477" height="571" alt="image" src="https://github.com/user-attachments/assets/53273dc1-0de3-4241-ac1c-1b1a1078432d" />


---

## Задание 6.3

**Текст задания**  
Определить, есть ли в очереди L хотя бы один элемент, который равен следующему за ним (по кругу) элементу (первый элемент считать следующим для последнего).

**Описание**  
Класс CountQueue содержит статический метод hasEqualNum. Метод принимает очередь целых чисел. Если очередь пуста или содержит один элемент, возвращается false. Создается временная копия очереди. Проход по очереди выполняется с сравнением текущего элемента с предыдущим. Если найден равный соседний элемент, возвращается true. После прохода всех элементов проверяется равенство последнего элемента и первого (замыкание по кругу). Если найдено совпадение, возвращается true, иначе false.

**Тестирование**  
<img width="556" height="383" alt="image" src="https://github.com/user-attachments/assets/e0ce05c9-aefd-4a40-8496-3499b2156d7a" />


---

## Задание 7.1

**Текст задания**  
Необходимо написать стрим: Дан набор объектов типа Point, необходимо взять все Point в разных координатах, убрать с одинаковыми X,Y, отсортировать по X, отрицательные Y сделать положительными и собрать это все в ломаную (объект типа Polyline) Если раннее в вашем варианте не было задание с классом Point и Polyline, то написать их: 
1. класс Point:
   • Координата X: число.
   • Координата Y: число.
   • Может возвращать текстовое представление вида "{X;Y}".
2. класс Line (Линия), расположенная на двумерной плоскости, которая описывается:
   • Координата начала: Точка
   • Координата конца: Точка
   • Может возвращать текстовое представление вида "Линия от {X1;Y1} до {X2;Y2}"
3. класс Polyline (Ломаная), которая будет представлять собой ломаную линию. Ломаная линия представляет собой набор следующих характеристик:
   • Имеет массив Точек, через которые линия проходит.
   • Может быть приведена к строковой форме вида "Линия [T1,T2,...,TN]", где TN -- это результат приведения к строке Точки с номером N

**Описание**  
Класс Point представляет точку с координатами x и y. Методы getX и getY возвращают координаты. Метод toString возвращает строковое представление точки. Методы equals и hashCode переопределены для корректного сравнения точек. Класс Polyline представляет ломаную линию, хранящую массив точек. Конструктор принимает массив точек. Метод toString возвращает строковое представление ломаной. Класс StreamProcessor содержит статический метод processPoints, который обрабатывает список точек с помощью Stream API. Выполняются операции: distinct для удаления дубликатов (использует equals и hashCode Point), sorted для сортировки по x, map для преобразования точек с отрицательным y в положительный (абсолютное значение), сбор результата в массив точек. Создается и возвращается объект Polyline из полученного массива точек.

**Тестирование**  
<img width="803" height="307" alt="image" src="https://github.com/user-attachments/assets/48c6b57b-7c42-4f91-ba4b-5369b85c83b0" />


---

## Задание 7.2

**Текст задания**  
Дан текстовый файл со строками, содержащими имя человека и его номер в следующей форме: Вася:5 Петя:3 Аня:5 Номера людей могут повторяться. У каких-то людей может не быть номера. Необходимо написать стрим выполняющую следующее: читаются все люди из файла, все имена приводится к нижнему регистру, но с первой буквой в верхнем регистре, убираем из перечня всех людей без номеров, а имена оставшихся группируются по их номеру: [5;[Вася, Аня], 3;[Петя]]

**Описание**  
Класс PersonProcessor содержит статический метод processPeople. Метод читает строки из файла с помощью BufferedReader и streams. Каждая строка разбивается по символу ':'. Фильтруются строки, имеющие ровно две части и непустой номер. Имена преобразуются к формату с первой заглавной буквой и остальными строчными. Результат группируется по номеру (ключ - целое число) в Map, где значение - список имен. Используются операции streams: map, filter, groupingBy, mapping. Возвращается Map<Integer, List<String>>, представляющая сгруппированные по номерам имена.

**Тестирование**  
<img width="346" height="584" alt="image" src="https://github.com/user-attachments/assets/7f969dd0-4786-4992-9f8b-388dd51563be" />
